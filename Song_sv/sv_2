//1.过程块
//过程块主要分为3个部分
//always  initial  final
//这前俩个部分在仿真时是不分先后执行的，final则一般放在最后
//
always @() begin
    
end
//
initial begin
    
end
//
final 


//对always的具体类型细分
/////////////////////////////////////////////////////////////

//always_comb
always_comb begin 
    if (sel) 
        out=a;
        out=b;
    else     
end
//该类型无敏感词，不会像@中，以@框号内的变量变动，再进行内容执行
//comb直接执行

/////////////////////////////////////////////////////////////

//always@
always @(*) begin
    if (sel) 
        out=a;
        out=b;
    else     
end

/////////////////////////////////////////////////////////////

//always_latch生成锁存器
always_latch begin 
    if(enable) out=in;//锁存逻辑
end
//实际上，当if不完全时，即无else时，一般就成为锁存器

/////////////////////////////////////////////////////////////
//always_ff与always@(posedge clk)很接近，用于描述触发器




//final部分
//一般只在仿真结束的最后部分才执行
//可能会做一些打印，打印的结果要在modelsim或者vcs中才能看见
final begin
    $display("");//打印的可能是提示仿真结束了
end



//2.过程语句控制

//顺序：---面试考点
begin end //内部各子线程按顺序执行
fork join //内部各子线程并行，直到所有子线程运行完毕才会进入下一个阶段
fork join_any //内部各子线程并行，任意一个子线程运行结束就可以进入下一个阶段
fork join_none //内部各子线程并行，无需等待直接进入下一个阶段

//可以对过程块命名，同时内部的变量可通过整个名字进行修改
begin:add
    int s;
    parameter p = 100;
    s=a+p;
end:add



//3.进程
