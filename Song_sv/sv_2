//1.过程块
//过程块主要分为3个部分
//always  initial  final
//这前俩个部分在仿真时是不分先后执行的，final则一般放在最后
//
always @() begin
    
end
//
initial begin
    
end
//
final 


//对always的具体类型细分
/////////////////////////////////////////////////////////////

//always_comb
always_comb begin 
    if (sel) 
        out=a;
        out=b;
    else     
end
//该类型无敏感词，不会像@中，以@框号内的变量变动，再进行内容执行
//comb直接执行

/////////////////////////////////////////////////////////////

//always@
always @(*) begin
    if (sel) 
        out=a;
        out=b;
    else     
end

/////////////////////////////////////////////////////////////

//always_latch生成锁存器
always_latch begin 
    if(enable) out=in;//锁存逻辑
end
//实际上，当if不完全时，即无else时，一般就成为锁存器

/////////////////////////////////////////////////////////////
//always_ff与always@(posedge clk)很接近，用于描述触发器




//final部分
//一般只在仿真结束的最后部分才执行
//可能会做一些打印，打印的结果要在modelsim或者vcs中才能看见
final begin
    $display("");//打印的可能是提示仿真结束了
end



//2.过程语句控制

//顺序：---面试考点
begin end //内部各子线程按顺序执行
fork join //内部各子线程并行，直到所有子线程运行完毕才会进入下一个阶段
fork join_any //内部各子线程并行，任意一个子线程运行结束就可以进入下一个阶段
fork join_none //内部各子线程并行，无需等待直接进入下一个阶段

//可以对过程块命名，同时内部的变量可通过整个名字进行修改
begin:add
    int s;
    parameter p = 100;
    s=a+p;
end:add



//3.进程

//wait
//相当于设置个断点，括号内的条件为真后，继续往下执行与@的区别在于，wait 类似电平触发，而@类似边沿触发
wait(a==1)
//eg：wait()阻断begin的进程，仅有在a==1时。继续执行display
begin
    #10;
    wait(a==1);
    $display("aaa");
end

//wait_fork
module test;
  initial begin
    $display("父进程: 开始执行 at %0t", $time);
    
    // 启动3个子进程，用join_none让父进程不等待，立即继续
    fork
      // 子进程1：延迟20ns后打印
      begin
        #20;
        $display("子进程1: 执行完毕 at %0t", $time);
      end
      
      // 子进程2：延迟10ns后打印
      begin
        #10;
        $display("子进程2: 执行完毕 at %0t", $time);
      end
      
      // 子进程3：延迟30ns后打印
      begin
        #30;
        $display("子进程3: 执行完毕 at %0t", $time);
      end
    join_none  // 父进程不等待子进程，直接继续
    
    $display("父进程: 子进程已启动，继续执行 at %0t", $time);
    
    // 等待所有子进程执行完毕
    wait_fork;//在所有子程序都执行完毕后，才执行wait_fork下面的语句
    $display("父进程: 所有子进程已完成，继续执行 at %0t", $time);
    
    $display("父进程: 结束 at %0t", $time);
  end
endmodule

//disable
disable;
//调用 disable 语句将会终止指定的进程

//disable_fork
disable_fork;
//作用范围是当前线程的子线程，以及子线程的子线程，子子孙孙全被终结,常用于环境复位



//4.事件和通信
//仿真原理
time-slot--->ts;//EDA工具仿真时的最小时间单位

//事件
event e;

->e;//相当于对e这个事件进行触发
@hierarchical_event_identifier;//"@"操作符阻塞调用进程直到指定的事件被触发



//5.接口
interface simple_bus
  logic b=1;
endinterface //simple_buslogic

module inst1 (
  simple_bus vif, //相当于是引用了接口里的所有信号
  input logic clk
);
  b=vif.b;
endmodule

module top;
  simple_bus top_vif();
  inst1 inst (top_vif,clk);
endmodule




//6.modport和clocking块
//modport 起到的就是整理 interface 内部的信号输入输出方向的作用，所以它整理的信号必须要是事先在 interface 中定义好的信号
//Clocking 可以保证接口内的信号可以同步地驱动和采样

clocking cb @(posedge clk);
    input a;//clocking内部的输入输出信号方向，是以tb为主体的，dut的输出，对于tb而言就是输入；
    input b;
    input c;
    output d;
endclocking

interface simple_bus(input logic clk);
    //先对接口内部的信号（想要捆绑的信号）进行类型位宽定义
    logic gnt, rdy, req, start;
    logic [1:0] mode;
    logic [7:0] addr, data;

    //在端口内声明接口捆绑信号的方向
    modport cpu (
    input gnt,rdy,
    output req,addr,mode,start,
    inout data
    );

    modport mem (
    output gnt,rdy,
    input req,addr,mode,start,
    inout data
    );
endinterface
